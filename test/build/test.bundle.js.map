{
  "version": 3,
  "sources": ["../../src/libxmlloader.ts", "../../src/validateFormWell.ts", "../../src/provider/MapInputProvider.ts", "../../src/util/helper.ts", "../../src/validateTowardXsd.ts", "worker:D:\\data_ferdi\\application\\xml-xsd_validation-browser\\src\\worker\\validator.worker", "../../src/validate.ts", "../test.ts"],
  "sourcesContent": ["import { ValidationInfo, WorkerBags } from \"./types\";\r\n\r\ntype LibLoader = {\r\n  libxml: any | null,\r\n  initError: any | null,\r\n}\r\n\r\nconst loader:LibLoader = {\r\n  libxml: null,\r\n  initError: null,\r\n}\r\n\r\nfunction libxml(){\r\n  return loader.libxml;\r\n}\r\n\r\n/**\r\n * To ensure that libxml2 has loaded, to let the worker can process.\r\n * @returns Promise array contains validation info or an error instance of XmlError or XmlValidateError owned by libxml2-wasm \r\n */\r\nexport async function ensureLibxml2Loaded(): Promise<ValidationInfo[]> {\r\n  return new Promise(async (resolve, reject) => {\r\n    if ((loader).libxml || loader.initError) return resolve([]);\r\n    try {\r\n      // dynamic import to avoid bundler import shape issues\r\n      const mod = await import(\"libxml2-wasm\");\r\n      (loader).libxml = mod;\r\n      return resolve([]);\r\n      // Note: libxml2.mjs already runs moduleLoader() at top-level (it awaits moduleLoader)\r\n      // so simply importing gives us ready exports.\r\n    } catch (e) {\r\n      loader.initError = e;\r\n      loader.initError.data = [{\r\n        name: \"LibInitError\",\r\n        type: \"none\",\r\n        details: {\r\n          message: loader.initError?.message || String(loader.initError),\r\n          file: \"\",\r\n          line: 1,\r\n          col: 1,\r\n        }\r\n      }]\r\n      return reject(loader.initError);\r\n    }\r\n  })\r\n}\r\n\r\nexport function useLibXml2(){\r\n  return {\r\n    libxml, ensureLibxmlLoaded: ensureLibxml2Loaded\r\n  }\r\n}", "import { useLibXml2 } from \"./libxmlloader\";\r\nimport { WorkerBags } from \"./types\";\r\n\r\n/**\r\n * \u2705 Validasi XML hanya untuk memastikan well-formed\r\n * - Menggunakan libxml2-wasm (WASM, aman di Worker)\r\n * - Output sesuai struktur ValidationErrorInfo\r\n */\r\nexport async function validateWellForm(xmlText: string): Promise<WorkerBags> {\r\n  const errorBags: WorkerBags = [];\r\n  const { libxml,  ensureLibxmlLoaded } = useLibXml2();\r\n  return ensureLibxmlLoaded()\r\n    .then(() => {\r\n      libxml().XmlDocument.fromString(xmlText);\r\n      return Promise.resolve([]);\r\n    })\r\n    .catch((err:any) => {\r\n      // to check wheer err is instance of XMlParseError. Use attribute details because class instance cannot used in worker\r\n      if (err.details) {\r\n        const detail = (err as any).details || {};\r\n        errorBags.push({\r\n          name: \"XMLParseError\",\r\n          type: \"form\",\r\n          detail: {\r\n            message: detail.message || err.message || \"Invalid XML format\",\r\n            file: detail.file || \"\",\r\n            line: detail.line?.toString() || 1,\r\n            col: detail.col?.toString() || 1,\r\n          },\r\n        });\r\n      } else {\r\n        if(err.data) errorBags.push(...err.data);\r\n        errorBags.push({\r\n          name: \"UnknownError\",\r\n          type: \"form\",\r\n          detail: {\r\n            message: err?.message || String(err),\r\n            file: \"\",\r\n            line: 1,\r\n            col: 1,\r\n          },\r\n        });\r\n      }\r\n      return Promise.reject(errorBags)\r\n    })\r\n}", "// import {\r\n//   xmlRegisterInputProvider,\r\n//   xmlCleanupInputProvider,\r\n// } from \"libxml2-wasm\";\r\n\r\nimport { useLibXml2 } from \"../libxmlloader\";\r\nimport { MapInputProvider, Schema } from \"../types\";\r\n\r\n/**\r\n * Create a virtual file provider for libxml2-wasm.\r\n * It maps filenames (or URLs) to in-memory schema contents,\r\n * allowing libxml2 to resolve xs:import/xs:include directly\r\n * without needing network access.\r\n */\r\nexport async function createMapInputProvider(map: Map<string, string> | Array<Schema>) :Promise<MapInputProvider> {\r\n  const { libxml, ensureLibxmlLoaded } = useLibXml2();\r\n\r\n  await ensureLibxmlLoaded()\r\n\r\n  const xmlRegisterInputProvider = libxml().xmlRegisterInputProvider;\r\n  const xmlCleanupInputProvider = libxml().xmlCleanupInputProvider;\r\n\r\n  const store = new Map<string, Uint8Array>();\r\n  const handles = new Map<number, { pos: number; data: Uint8Array }>();\r\n  let nextFd = 1;\r\n\r\n  // --- utilities ---\r\n  const toUint8 = (s: string) => new TextEncoder().encode(s);\r\n\r\n  const normalizeKey = (k: string) => {\r\n    if (!k) return k;\r\n    try {\r\n      const u = new URL(k);\r\n      return u.href;\r\n    } catch {\r\n      return k;\r\n    }\r\n  };\r\n\r\n  const basename = (path: string) => {\r\n    try {\r\n      const u = new URL(path);\r\n      return u.pathname.split(\"/\").pop() || path;\r\n    } catch {\r\n      const parts = path.split(\"/\");\r\n      return parts[parts.length - 1] || path;\r\n    }\r\n  };\r\n\r\n  // --- initialize store ---\r\n  if (map instanceof Map) {\r\n    for (const [k, v] of map.entries()) store.set(normalizeKey(k), toUint8(v));\r\n  } else {\r\n    for (const { filename, contents } of map)\r\n      store.set(normalizeKey(filename), toUint8(contents));\r\n  }\r\n\r\n  // Also add basenames for fallback\r\n  for (const key of Array.from(store.keys())) {\r\n    const base = basename(key);\r\n    if (!store.has(base)) {\r\n      store.set(base, store.get(key)!);\r\n    }\r\n  }\r\n\r\n  // --- provider implementation ---\r\n  const match = (filename: string): boolean => {\r\n    if (!filename) return false;\r\n    const n = normalizeKey(filename);\r\n    if (store.has(n)) return true;\r\n    const base = basename(n);\r\n    if (store.has(base)) return true;\r\n    for (const k of store.keys()) {\r\n      if (n.endsWith(k) || k.endsWith(n)) return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const open = (filename: string): number | undefined => {\r\n    const n = normalizeKey(filename);\r\n    let data = store.get(n);\r\n    if (!data) {\r\n      const base = basename(n);\r\n      data = store.get(base);\r\n    }\r\n    if (!data) {\r\n      for (const [k, v] of store.entries()) {\r\n        if (n.endsWith(k) || k.endsWith(n)) {\r\n          data = v;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (!data) return undefined;\r\n    const fd = nextFd++;\r\n    handles.set(fd, { pos: 0, data });\r\n    return fd;\r\n  };\r\n\r\n  const read = (fd: number, buf: Uint8Array): number => {\r\n    const h = handles.get(fd);\r\n    if (!h) return -1;\r\n    const remaining = h.data.length - h.pos;\r\n    if (remaining <= 0) return 0;\r\n    const toCopy = Math.min(buf.byteLength, remaining);\r\n    buf.set(h.data.subarray(h.pos, h.pos + toCopy), 0);\r\n    h.pos += toCopy;\r\n    return toCopy;\r\n  };\r\n\r\n  const close = (fd: number): boolean => handles.delete(fd);\r\n\r\n  // --- register / cleanup ---\r\n  const register = () => {\r\n    return xmlRegisterInputProvider({\r\n      match,\r\n      open,\r\n      read,\r\n      close,\r\n    } as any);\r\n  };\r\n\r\n  const cleanup = () => {\r\n    xmlCleanupInputProvider();\r\n  };\r\n\r\n  // expose methods\r\n  return {\r\n    match,\r\n    open,\r\n    read,\r\n    close,\r\n    register,\r\n    cleanup,\r\n  };\r\n}\r\n", "/**\r\n * Rekursif mendeteksi semua dependency XSD dari schema utama,\r\n * handle xs:import, xs:include, dan xs:redefine\r\n * \r\n * Tidak menggunakan async/await, seluruhnya Promise chaining.\r\n * Menangani error dengan console.error, tetap resolve agar tidak menghentikan chain.\r\n * array index 0 adalah mainSchemaUrl\r\n */\r\n\r\nimport { Schema } from \"../types\";\r\n\r\nexport async function findRequiredSchemas(\r\n  mainSchemaUrl: string,\r\n  visited = new Set<string>()\r\n): Promise<Schema[]> {\r\n  if (visited.has(mainSchemaUrl)) {\r\n    return Promise.resolve([]);\r\n  }\r\n  visited.add(mainSchemaUrl);\r\n\r\n  return fetch(mainSchemaUrl)\r\n    .then((res) => {\r\n      if (!res.ok) throw new Error(`Gagal fetch schema: ${mainSchemaUrl}`);\r\n      return res.text();\r\n    })\r\n    .then(async (text) => {\r\n      const regex = /<[a-zA-Z]{2}:(?:import|include|redefine)[^>]*schemaLocation=\"([^\"]+)\"/g;\r\n      const matches = Array.from(text.matchAll(regex));\r\n      const base = new URL(mainSchemaUrl);\r\n\r\n      const nestedUrls: string[] = [];\r\n      for (const match of matches) {\r\n        try {\r\n          const resolved = new URL(match[1], base).href;\r\n          if (!visited.has(resolved)) nestedUrls.push(resolved);\r\n        } catch (e) {\r\n          console.warn(\"URL tidak valid:\", match[1]);\r\n        }\r\n      }\r\n\r\n      return Promise.all(\r\n        nestedUrls.map((url) => findRequiredSchemas(url, visited))\r\n      )\r\n        .then((nestedSchemasArrays) => {\r\n          const nestedSchemas = nestedSchemasArrays.flat();\r\n          return Promise.resolve([{ filename: mainSchemaUrl, contents: text }, ...nestedSchemas]);\r\n        });\r\n    })\r\n    .catch((err) => {\r\n      console.error(\"findRequiredSchemas error:\", err);\r\n      // Jangan throw lagi \u2014 tetap resolve agar proses tidak berhenti\r\n      return Promise.reject([]);\r\n    });\r\n}\r\n\r\n/**\r\n * Ambil URL schema dari atribut `xsi:noNamespaceSchemaLocation`\r\n * atau `xsi:schemaLocation`.\r\n */\r\nexport function extractSchemaLocation(xmlText: string): string | null {\r\n  // Cari noNamespaceSchemaLocation\r\n  const noNsMatch = xmlText.match(\r\n    /\\b[a-zA-Z0-9]+:noNamespaceSchemaLocation\\s*=\\s*[\"']([^\"']+)[\"']/i\r\n  );\r\n  if (noNsMatch) return noNsMatch[1];\r\n\r\n  // Cari schemaLocation (bisa punya banyak pasangan namespace + URL)\r\n  const schemaLocMatch = xmlText.match(\r\n    /\\bxsi:schemaLocation\\s*=\\s*[\"']([^\"']+)[\"']/i\r\n  );\r\n\r\n  if (schemaLocMatch) {\r\n    // schemaLocation bisa berisi banyak pasangan:\r\n    // \"ns1 url1 ns2 url2 ...\" \u2192 ambil semua URL yang kelihatan valid\r\n    const parts = schemaLocMatch[1].trim().split(/\\s+/);\r\n    const urls = parts.filter(p => /^https?:\\/\\/|\\.xsd$/i.test(p));\r\n    return urls[0] || null;\r\n  }\r\n\r\n  // Tidak ditemukan\r\n  return null;\r\n}\r\n\r\n/**\r\n * to check wheter the param is xml text or url\r\n * @param file url or xml text file\r\n * @returns \r\n */\r\nexport function isXmlLike(file: string): boolean {\r\n  if (typeof file !== 'string') {\r\n    return false; // Not a string\r\n  }\r\n  // Check for common XML elements and structure\r\n  return file.includes('<') && file.includes('>') &&\r\n    (file.includes('<?xml') || file.includes('</'));\r\n}\r\n\r\n/**\r\n * to get xml text from url.\r\n * @param file url or xml contents\r\n * @returns xml text\r\n */\r\nexport async function getXmlText(file: string): Promise<string> {\r\n  if (isXmlLike(file)) {\r\n    return Promise.resolve(file);\r\n  } else {\r\n    const fileurl = (new URL(file, window.location.href)).href;\r\n    return fetch(fileurl).then(r => r.text())\r\n  }\r\n}\r\n\r\n", "import { ErrorDetail, XsdValidator } from \"libxml2-wasm\";\r\nimport { createMapInputProvider } from \"./provider/MapInputProvider\";\r\nimport { MapInputProvider, Schema, WorkerBags } from \"./types\";\r\nimport { extractSchemaLocation, findRequiredSchemas, getXmlText } from \"./util/helper\";\r\nimport { useLibXml2 } from \"./libxmlloader\";\r\n\r\n/**\r\n * logic validate xml toward xsd.\r\n * @param file url or xml contents\r\n * @param mainSchemaUrl url\r\n * @returns \r\n */\r\nexport async function validateXmlTowardXsd(file: string, mainSchemaUrl: string | null = null, stopOnFailure: boolean = true): Promise<WorkerBags> {\r\n  const { libxml, ensureLibxmlLoaded } = useLibXml2();\r\n  let provider: MapInputProvider | null = null;\r\n  const bags: WorkerBags = [];\r\n\r\n  // 0) ensure libxml\r\n  await ensureLibxmlLoaded();\r\n  // 1). Load xmlText\r\n  let xmlText: string;\r\n  try {\r\n    xmlText = await getXmlText(file)\r\n  } catch {\r\n    console.warn(\"Warning: Failed to fetch xml content\");\r\n    bags.push({\r\n      name: \"FetchError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to fetch xml content\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n  mainSchemaUrl = mainSchemaUrl ?? extractSchemaLocation(xmlText!);\r\n  if (!mainSchemaUrl) {\r\n    console.warn(\"Warning: Failed to fetch xml content\");\r\n    bags.push({\r\n      name: \"FetchError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to get schema location\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n  // 2). Load required schema\r\n  let schemas: Schema[] | null = null\r\n  try {\r\n    schemas = await findRequiredSchemas(mainSchemaUrl!)\r\n  } catch (error) {\r\n    console.warn(\"Warning: Failed to find required schemas\");\r\n    bags.push({\r\n      name: \"FetchError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to find required schemas\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n  // 3) create provider\r\n  try {\r\n    provider = await createMapInputProvider(schemas!);\r\n    provider!.register();\r\n  } catch (error) {\r\n    console.warn(\"Warning: xmlRegisterInputProvider returned false\");\r\n    bags.push({\r\n      name: \"RegisteringProviderError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to create/register provider\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n\r\n  // 4) load XML & main XSD doc (main xsd still parsed from string)\r\n  const mainXsdText = schemas![0].contents;\r\n  let xmlDoc: any;\r\n  let xsdDoc: any;\r\n  try {\r\n    xmlDoc = libxml().XmlDocument.fromString(xmlText!);\r\n    xsdDoc = libxml().XmlDocument.fromString(mainXsdText);\r\n  } catch (error) {\r\n    console.warn(\"Warning: XML and XSD Document fail to parsed\");\r\n    bags.push({\r\n      name: \"XMLParseError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to create instance of Xml and Xsd document\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      provider?.cleanup();\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n  // 5) create validator\r\n  let validator: any;\r\n  try {\r\n    validator = libxml().XsdValidator.fromDoc(xsdDoc!);\r\n  } catch (error) {\r\n    console.warn(\"Warning: Failed to create Xsd validator\");\r\n    bags.push({\r\n      name: \"XSDValidatorParseError\",\r\n      type: \"xsd\",\r\n      detail: {\r\n        message: \"Failed to create Xsd validator\",\r\n        col: 1,\r\n        line: 1,\r\n        file: \"\"\r\n      }\r\n    })\r\n    if (stopOnFailure) {\r\n      provider?.cleanup();\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n  // 6) validate\r\n  try {\r\n    validator!.validate(xmlDoc!);\r\n  } catch (error: any) {\r\n    for (const d of error.details) {\r\n      bags.push({\r\n        name: \"XMLValidateError\",\r\n        type: \"xsd\",\r\n        detail: {\r\n          message: d.message || \"XSD Validation failed\",\r\n          file: d.file || \"\",\r\n          line: d.line || 1,\r\n          col: d.col || 1,\r\n        },\r\n      });\r\n    }\r\n    if (stopOnFailure) {\r\n      provider?.cleanup();\r\n      return Promise.reject(bags);\r\n    }\r\n  }\r\n\r\n  // 6) cleanup\r\n  provider?.cleanup();\r\n\r\n  return Promise.reject(bags)\r\n}", "\n          export default function WorkerWrapper() {\n            return new Worker(new URL(\"./validator.worker.js\", import.meta.url), { type: \"module\" });\n          }\n        ", "import { validateWellForm } from \"./validateFormWell\";\r\nimport { UseWorker, ValidationInfo, ValidationPayload, WorkerPayload, WorkerResponse } from \"./types\";\r\nimport { validateXmlTowardXsd } from \"./validateTowardXsd\";\r\nimport ValidatorWorker from \"./worker/validator.worker?worker\";\r\n\r\n/**\r\n * TBD, akan memvalidate xml berdasarkan namespace\r\n * tidak berjalan di worker\r\n * xsi:schemaLocation may contain two xsd, eg. xsi:schemaLocation=\"namespace1 xsd1 namespace2 xsd2\"\r\n */\r\nexport async function validateXml(xmlText: string, mainSchemaUrl: string | null = null, stopOnFailure: boolean = true): Promise<ValidationInfo[]> {\r\n  const errors: ValidationInfo[] = [];\r\n  return validateWellForm(xmlText)\r\n    .then((validateWellFormInfos): ValidationInfo[] | Promise<ValidationInfo[]> => {\r\n      errors.push(...validateWellFormInfos);\r\n      if (!stopOnFailure || (errors.length < 1)) {\r\n        return validateXmlTowardXsd(xmlText, mainSchemaUrl, stopOnFailure)\r\n          .then((validateXmlTowardXsdInfos) => {\r\n            if (validateXmlTowardXsdInfos) {\r\n              errors.push(...validateXmlTowardXsdInfos)\r\n            }\r\n            return errors;\r\n          })\r\n      }\r\n      return errors;\r\n    })\r\n}\r\n\r\n// function reactiveStatus(init: string) {\r\n//   let value = init;\r\n//   let listeners: Function[] = [];\r\n\r\n//   return {\r\n//     get value() {\r\n//       return value;\r\n//     },\r\n//     set value(v) {\r\n//       value = v;\r\n//       listeners.forEach(fn => fn(v));\r\n//     },\r\n//     reset() {\r\n//       listeners = [];\r\n//     },\r\n//     watch(fn: Function) {\r\n//       listeners.push(fn);\r\n//     },\r\n//     when(predicate: Function) {\r\n//       return new Promise(resolve => {\r\n//         if (predicate(value)) resolve(value);\r\n//         else this.watch((v: any) => predicate(v) && resolve(v));\r\n//       });\r\n//     }\r\n//   };\r\n// }\r\n// contoh penggunaan reactiveStatus:\r\n// const wstatus = reactiveStatus(\"working\");\r\n// let s1:any = wstatus.when(v => v !== \"working\").then(v => s1 = v);\r\n// wstatus.value = \"done\"; // \u2705 langsung resolve\r\n\r\nexport function useWorker(): UseWorker {\r\n  const validatorWorker = new ValidatorWorker();\r\n  const _responses = new Map<\r\n    string,\r\n    { resolve: (res: WorkerResponse) => void; reject: (err?: any) => void }\r\n  >();\r\n\r\n  validatorWorker.onmessage = (e: MessageEvent<WorkerResponse>) => {\r\n    const { id, status, bags } = e.data;\r\n    if (status) {\r\n      if (_responses.has(id)) {\r\n        const { resolve } = _responses.get(id)!;\r\n        resolve({ id, status, bags });\r\n        _responses.delete(id)\r\n\r\n      }\r\n    } else {\r\n      const { reject } = _responses.get(id)!;\r\n      reject({ id, status, bags });\r\n      _responses.delete(id)\r\n    }\r\n  }\r\n\r\n  validatorWorker.onerror = function (e: ErrorEvent) {\r\n    throw new Error(\"Worker error\");\r\n  }\r\n\r\n  const terminate = () => {\r\n    validatorWorker.terminate();\r\n\r\n  }\r\n\r\n  const validate = (xmlText: string, mainSchemaUrl: string | null, stopOnFailure: boolean = true): Promise<WorkerResponse> => {\r\n    const id = crypto.randomUUID();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      _responses.set(id, {resolve, reject});\r\n\r\n      const payload: WorkerPayload<ValidationPayload> = {\r\n        id,\r\n        payload: { xmlText, mainSchemaUrl, stopOnFailure }\r\n      }\r\n      validatorWorker.postMessage(payload)\r\n    })\r\n  }\r\n\r\n  return {\r\n    validate, terminate\r\n  }\r\n}", "import { ValidationInfo, WorkerResponse } from \"../src/types\";\r\nimport { useWorker, validateXml } from \"../src/validate\";\r\n\r\n// const fileurl = \"/test/xml_file.xml\";\r\n// const xmlText = await getXmlText(fileurl);\r\n\r\nfunction appendToHTML(idEl: string, errors: ValidationInfo[]) {\r\n  const container = document.getElementById(idEl)\r\n  if (container) {\r\n    errors.forEach((err, i) => {\r\n      const div = document.createElement(\"div\");\r\n      div.className = \"error-item\";\r\n      div.innerHTML = `\r\n<strong>${i + 1}. ${err.name}</strong>\r\n<em>(${err.type})</em>\r\n<br>\r\n  <pre>${err.detail.message.trim()}</pre>\r\n  <small>Line: ${err.detail.line}, Col: ${err.detail.col}</small>\r\n      `;\r\n      container.appendChild(div);\r\n    });\r\n  }\r\n}\r\n\r\nfunction test1() {\r\n  const xmlText =\r\n  `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE dmodule >\r\n  <dmodule xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:dc=\"http://www.purl.org/dc/elements/1.1/\"\r\n    xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\" xsi:noNamespaceSchemaLocation=\"https://ferdisap.github.io/schema/s1000d/S1000D_5-0/xml_schema_flat/appliccrossreftable.xsd\">\r\n    <identAndStatusSection></identAndStatusSection>\r\n  </dmodule>`;\r\n  validateXml(xmlText)\r\n    .catch(bags => {\r\n      console.log(bags) // returning array contains object has name:\"XMLValidateError\"\r\n      appendToHTML(\"for_test_1\", bags);\r\n    })\r\n}\r\ntest1()\r\n\r\nasync function test2() {\r\n  const xmlText =\r\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>  <!DOCTYPE dmodule >\r\n  <dmodule>\r\n    <identAndStatusSection></identAndStatusSection>\r\n  </dmodule>`;\r\n  const mainSchemaUrl = \"http://www.s1000d.org/S1000D_5-0/xml_schema_flat/appliccrossreftable.xsd\"; // CORS\r\n\r\n  const { validate, terminate } = useWorker()\r\n  validate(xmlText, mainSchemaUrl)\r\n    // never get resolved if the file is valid\r\n    .then((response:WorkerResponse) => {\r\n      const { id, status, bags } = response;\r\n      console.log(id, status, bags) \r\n      appendToHTML(\"for_test_2\", bags);\r\n    })\r\n    .catch((response:WorkerResponse) => {\r\n      const { id, status, bags } = response;\r\n      console.log(id, status, bags)\r\n      appendToHTML(\"for_test_2\", bags); // returning array contains object has name:\"Fetch Error\" because CORS\r\n      terminate()\r\n    })\r\n\r\n}\r\ntest2()\r\n\r\n// expected\r\n/**\r\n[\r\n  {\r\n    name: \"XMLValidateError\",\r\n    type: \"xsd\",\r\n    detail: {\r\n      message: \"Element 'identAndStatusSection': Missing child element(s). Expected is ( dmAddress ).\\\\n\",\r\n      file: \"\",\r\n      line: 3,\r\n      col: 1\r\n    }\r\n  },\r\n  {\r\n    name: \"XMLValidateError\",\r\n    type: \"xsd\",\r\n    detail: {\r\n      message: \"Element 'dmodule': Missing child element(s). Expected is ( content ).\\\\n\",\r\n      file: \"\",\r\n      line: 2,\r\n      col: 1\r\n    }\r\n  }\r\n]\r\n*/\r\n"],
  "mappings": "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",
  "names": ["libxml", "libxml", "libxml"]
}
