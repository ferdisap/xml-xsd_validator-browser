class l{constructor(){this.storage=new Map,this.index=0}allocate(t){return this.index+=1,this.storage.set(this.index,t),this.index}free(t){this.storage.delete(t)}get(t){return this.storage.get(t)}}const o=new Map;let i=1;class h{constructor(t){this._data=t}addBuffer(t,r){this._data[t]=r}removeBuffer(t){delete this._data[t]}match(t){return this._data[t]!=null}open(t){return a(this._data[t])}read(t,r){return c(t,r)}close(t){return d(t),!0}}function a(e){const t=i;return o.set(t,[e,0]),i+=1,t}function c(e,t){const r=o.get(e);if(r==null)return-1;const[u,n]=r,s=Math.min(t.byteLength,u.byteLength-n);return t.set(u.slice(n,n+s)),r[1]+=s,s}function d(e){o.delete(e)}class f{constructor(){this._result="",this._decoder=new TextDecoder}write(t){return this._result+=this._decoder.decode(t),t.byteLength}close(){return!0}get result(){return this._result}}export{l as ContextStorage,h as XmlBufferInputProvider,f as XmlStringOutputBufferHandler,d as closeBuffer,a as openBuffer,c as readBuffer};
